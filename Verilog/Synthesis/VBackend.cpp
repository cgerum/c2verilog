/* Nadav Rotem  - C-to-Verilog.com */
#include "VTargetMachine.h"
#include "llvm/CallingConv.h"
#include "llvm/Constants.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Module.h"
#include "llvm/Instructions.h"
//#include "llvm/ParameterAttributes.h"
#include "llvm/Pass.h"
#include "llvm/PassManager.h"
#include "llvm/TypeSymbolTable.h"
#include "llvm/Intrinsics.h"
#include "llvm/IntrinsicInst.h"
#include "llvm/InlineAsm.h"
#include "llvm/Analysis/ConstantsScanner.h"
#include "llvm/Analysis/FindUsedTypes.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/CodeGen/IntrinsicLowering.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Target/TargetMachineRegistry.h"
#include "llvm/Target/TargetAsmInfo.h"
#include "llvm/Target/TargetData.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Support/CFG.h"
#include "llvm/Support/GetElementPtrTypeIterator.h"
#include "llvm/Support/InstVisitor.h"
#include "llvm/Support/Mangler.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Config/config.h"
#include <algorithm>
#include <sstream>
#include "llvm/Support/raw_ostream.h"

#include <llvm/ADT/DenseMap.h>
#include "llvm/Transforms/Utils/Cloning.h"

#include "listScheduler.h"
#include "verilogLang.h"
#include "designScorer.h"
#include "../params.h"

using namespace llvm;
using std::string;
using std::stringstream;
using llvm::TargetData; //JAWAD
namespace xVerilog {
    // Register the target.
    static RegisterTarget<VTargetMachine> MXVVE("v", "Verilog backend");
  
    /// VWriter - This class is the main chunk of code that converts an LLVM
    /// module to a Verilog translation unit.
    class VWriter : public FunctionPass {

        public:
            static char ID;
            VWriter(llvm::raw_ostream &o) 
                : FunctionPass((intptr_t)&ID),Out(o) {}

            virtual const char *getPassName() const { return "verilog backend"; }

            void getAnalysisUsage(AnalysisUsage &AU) const {
                AU.addRequired<LoopInfo>();
                AU.addPreserved<LoopInfo>();
	        AU.addRequired<TargetData>();//JAWAD 
                AU.setPreservesAll();
            }

            virtual bool doInitialization(Module &M);
            virtual bool doFinalization(Module &M);

            bool runOnFunction(Function &F);

        private:
            llvm::raw_ostream &Out;
            Mangler *Mang;
    };



    char VWriter::ID = 0;

    bool VWriter::runOnFunction(Function &F) { 
        for (Function::arg_iterator I = F.arg_begin(), E = F.arg_end(); I != E; ++I) { //JAWAD
                string argname = I->getName(); 
		argname = machineResourceConfig::chrsubst(argname,'.','_');
		I->setName (argname);
	};

        //DenseMap <const Value *, Value *> ValueMap;
        //Function *newFunc =  llvm::CloneFunction   (&F,ValueMap);  

        //std::cerr<<"Converting to verilog this function:\n" <<F<<"\n\n";

 	TargetData * TD =  &getAnalysis<TargetData>();//JAWAD
        verilogLanguage verilogPrinter(F.getParent(),Mang,TD);

        listSchedulerVector lv;

	Out<<   "/*       This module was generated by c-to-verilog.com\n"
		" * THIS SOFTWARE IS PROVIDED BY www.c-to-verilog.com ''AS IS'' AND ANY\n"
		" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n"
		" * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
		" * DISCLAIMED. IN NO EVENT SHALL c-to-verilog.com BE LIABLE FOR ANY\n"
		" * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n"
		" * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES)\n"
		" * \n"
		" * Found a bug? email info@c-to-verilog.com \n"
		" */\n\n\n";


        LoopInfo *LInfo = &getAnalysis<LoopInfo>();
        designScorer ds(LInfo);

        for (Function::iterator BB = F.begin(), E = F.end(); BB != E; ++BB) {
            listScheduler *ls = new listScheduler(BB,TD); //JAWAD
            lv.push_back(ls);
            ds.addListScheduler(ls);
        }

        map<string, unsigned int> resourceMap =
            machineResourceConfig::getResourceTable();

        unsigned int include_size = resourceMap["include_size"];
        unsigned int include_freq = resourceMap["include_freq"];
        unsigned int include_clocks = resourceMap["include_clocks"];
        float MDF = (float)resourceMap["delay_memport"];

        float freq = ds.getDesignFrequency();
        float clocks = ds.getDesignClocks();
        float gsize = ds.getDesignSizeInGates(&F);

        if (0==include_freq) freq = 1;
        if (0==include_clocks) clocks = 1;
        if (0==include_size) gsize = 1;

        cerr<<"\n\n---  Synthesis Report ----\n";
        cerr<<"Estimated circuit delay   : " << freq<<"ns ("<<1000/freq<<"Mhz)\n";
        cerr<<"Estimated circuit size    : " << gsize<<"\n";
        cerr<<"Calculated loop throughput: " << clocks<<"\n";
        cerr<<"--------------------------\n";

        Out<<"/* Total Score= |"<< ((clocks*sqrt(clocks))*(freq)*(gsize))/(MDF) <<"| */"; 
        Out<<"/* freq="<<freq<<" clocks="<<clocks<<" size="<<gsize<<"*/\n"; 
        Out<<"/* Clocks to finish= |"<< clocks <<"| */\n"; 
        Out<<"/* Design Freq= |"<< freq <<"| */\n"; 
        Out<<"/* Gates Count = |"<< gsize <<"| */\n"; 
        Out<<"/* Loop BB Percent = |"<< ds.getLoopBlocksCount() <<"| */\n"; 

        Out<<verilogPrinter.getFunctionSignature(&F,std::string(""));
        Out<<verilogPrinter.getMemDecl(&F);
        Out<<verilogPrinter.getFunctionLocalVariables(lv);
        Out<<verilogPrinter.getStateDefs(lv);

        Out<<verilogPrinter.getAssignmentString(lv);

        Out<<verilogPrinter.getClockHeader();
        Out<<"\n// Datapath \n";
        for (listSchedulerVector::iterator it=lv.begin(); it!=lv.end(); ++it) {
            Out<<verilogPrinter.printBasicBlockDatapath(*it);
        }

        Out<<"\n\n// Control \n";
        Out<<verilogPrinter.getCaseHeader();
        for (listSchedulerVector::iterator it=lv.begin(); it!=lv.end(); ++it) {
            Out<<verilogPrinter.printBasicBlockControl(*it);
        }

        Out<<verilogPrinter.getCaseFooter();
        Out<<verilogPrinter.getClockFooter();
        Out<<verilogPrinter.getModuleFooter();
        Out<<"\n\n// -- Library components --  \n";
        Out<<verilogPrinter.createBinOpModule("mul","*",resourceMap["delay_mul"]);
        Out<<verilogPrinter.createBinOpModule("div","/",resourceMap["delay_div"]);
        Out<<verilogPrinter.createBinOpModule("shl","<<",resourceMap["delay_shl"]);
        Out<<verilogPrinter.getBRAMDefinition(resourceMap["mem_wordsize"],resourceMap["membus_size"]);
        Out<<verilogPrinter.getTestBench(F);
        //std::cerr<<"done scheduling function\n";
        return true;
    }

    bool VWriter::doFinalization(Module &M) {
        globalVarRegistry gvr;
        gvr.destroy();
        delete Mang;
        return true;
    }

    bool VWriter::doInitialization(Module &M) { 
        Mang = new Mangler(M);
        Mang->markCharUnacceptable('.');
        globalVarRegistry gvr;
        gvr.init(&M);
        return true;
    }

} // namespace

//===----------------------------------------------------------------------===//
//                       External Interface declaration
//===----------------------------------------------------------------------===//

bool VTargetMachine::addPassesToEmitWholeFile(PassManager &PM, llvm::raw_ostream &o, 
        CodeGenFileType FileType, bool Fast) {
    if (FileType != TargetMachine::AssemblyFile) return true;

    PM.add(new xVerilog::VWriter(o));
    return false;
}
